#ifndef OPENMW_COMPONENTS_NIFBULLET_BULLETNIFLOADER_HPP
#define OPENMW_COMPONENTS_NIFBULLET_BULLETNIFLOADER_HPP

#include <cassert>
#include <string>
#include <set>
#include <iostream>
#include <map>

#include <osg/Matrixf>
#include <osg/BoundingBox>
#include <osg/ref_ptr>
#include <osg/Referenced>

#include <components/nif/niffile.hpp>

class btTriangleMesh;
class btCompoundShape;
class btCollisionShape;

namespace Nif
{
    class Node;
    struct Transformation;
    struct NiTriShape;
}

namespace NifBullet
{

class BulletShapeInstance;
class BulletShape : public osg::Referenced
{
public:
    BulletShape();
    virtual ~BulletShape();

    btCollisionShape* mCollisionShape;

    // Used for actors. Note, ideally actors would use a separate loader - as it is
    // we have to keep a redundant copy of the actor model around in mCollisionShape, which isn't used.
    // For now, use one file <-> one resource for simplicity.
    osg::Vec3f mCollisionBoxHalfExtents;
    osg::Vec3f mCollisionBoxTranslate;

    // Stores animated collision shapes. If any collision nodes in the NIF are animated, then mCollisionShape
    // will be a btCompoundShape (which consists of one or more child shapes).
    // In this map, for each animated collision shape,
    // we store the node's record index mapped to the child index of the shape in the btCompoundShape.
    std::map<int, int> mAnimatedShapes;

    osg::ref_ptr<BulletShapeInstance> makeInstance();

    btCollisionShape* duplicateCollisionShape(btCollisionShape* shape) const;

    btCollisionShape* getCollisionShape();

private:
    void deleteShape(btCollisionShape* shape);
};

// An instance of a BulletShape that may have its own unique scaling set on the mCollisionShape.
// Vertex data is shallow-copied where possible. A ref_ptr to the original shape needs to be held to keep vertex pointers intact.
class BulletShapeInstance : public BulletShape
{
public:
    BulletShapeInstance(osg::ref_ptr<BulletShape> source);

private:
    osg::ref_ptr<BulletShape> mSource;
};

/**
*Load bulletShape from NIF files.
*/
class BulletNifLoader
{
public:
    BulletNifLoader();

    virtual ~BulletNifLoader();

    void warn(const std::string &msg)
    {
        std::cerr << "NIFLoader: Warn:" << msg << "\n";
    }

    void fail(const std::string &msg)
    {
        std::cerr << "NIFLoader: Fail: "<< msg << std::endl;
        abort();
    }

    osg::ref_ptr<BulletShape> load(const Nif::NIFFilePtr file);

private:
    bool findBoundingBox(const Nif::Node* node, int flags = 0);

    void handleNode(Nif::Node const *node, int flags, bool isCollisionNode, bool isAnimated=false, bool autogenerated=false);

    bool hasAutoGeneratedCollision(const Nif::Node *rootNode);

    void handleNiTriShape(const Nif::NiTriShape *shape, int flags, const osg::Matrixf& transform, bool isAnimated);

    btCompoundShape* mCompoundShape;

    btTriangleMesh* mStaticMesh;

    osg::ref_ptr<BulletShape> mShape;
};

}

#endif
